<section id="adapterperformance" role="wrapper">
	<title>ListViews and performance</title>
	<section id="adapterperformance_motivation">
		<title>Motivation</title>
		<para>
			Performance is especially important on Android as users expect
			fast reaction times. Compared to desktop computers an Android
			device
			is relatively slow from the hardware perspective.
		</para>
		<para>
			This part describes how to reduce these operations to implement your
			custom list adapter efficiently. The default Android adapters like
			<code>ArrayAdapter</code>
			are already performance optimized.
		</para>
	</section>
	<section id="adapterperformance_problems">
		<title>Time consuming operations</title>
		<para>
			Every
			view
			which get inflated from an XML layout file will result
			in a Java
			object. Inflating layouts and creating Java objects is
			expensive with regards to
			time and
			memory
			consumption.
		</para>

		<para>
			In addition using the
			<code>findViewById()</code>
			method is relatively time consuming, even though it is not as bad
			as
			XML inflating.
		</para>

	</section>
	<section id="adapterperformance_convertview">
		<title>Avoiding layout inflation and object creation</title>
		<para>
			A
			<code>ListView</code>
			typically contains more data than the number of displayed rows.
			If the
			user scrolls
			the
			list, then rows and
			their
			associated
			views
			are being
			scrolled
			out of the visible area. The Java objects which
			represents the
			rows
			can be reused for newly visible rows.
		</para>
		<para>
			If Android determines that a
			row is not visible anymore, it allows the
			<code>getView()</code>
			of the adapter
			method to reuse the associated view via the
			<code>convertView</code>
			parameter.
		</para>
		<para>
			The adapter can
			assign
			new
			data to the views contained in the view
			hierarchy of the
			<code>convertView</code>
			. This avoids inflating an XML file and creating new Java objects.
		</para>
		<para>
			In case Android cannot reuse a row, the Android system passes
			<code>null</code>
			to the
			<code>convertView</code>
			parameter. Therefore the adapter implementation needs to check for
			this.
		</para>

	</section>
	<section id="adapterperformance_holder">
		<title>View holder pattern</title>
		<para>
			A
			<wordasword>ViewHolder</wordasword>
			implementation
			allows to avoid the
			<code>findViewById()</code>
			method in an adapter.
		</para>
		<para>
			A
			<code>ViewHolder</code>
			class is typically a static inner class in your adapter which holds references
			to
			the relevant views.
			in your layout. This reference is assigned to
			the
			row view as a tag via the
			<code>setTag()</code>
			method.
		</para>
		<para>
			If we receive a
			<code>convertView</code>
			object, we can get the instance of the
			<code>ViewHolder</code>
			via the
			<code>getTag()</code>
			method and assign the new attributes to the
			views
			via the
			<code>ViewHolder</code>
			reference.
		</para>

		<para>
			While this sounds complex this is approximately 15 % faster then
			using the
			<code>findViewById()</code>
			method.
		</para>
	</section>


	<section id="adapterperformance_example">
		<title>Example</title>
		<para>
			The following code shows a performance optimized adapter
			implementation which reuses existing views and implements the holder
			pattern.
		</para>
		<para>
			<programlisting language="java">
				<xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
					parse="text" href="./examples/layoutinflator/MyPerformanceArrayAdapter.java" />
			</programlisting>
		</para>


	</section>


</section>

