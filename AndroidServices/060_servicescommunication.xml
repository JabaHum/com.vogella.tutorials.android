<section id="servicecommunication" role="wrapper">
	<title>Communication with services</title>
	<section id="servicecommunication_overview">
		<title>Options for communication</title>
		<para>
			There are several possibilities for an
			activity
			to communicate
			with
			a
			service
			and vice versa. This section discusses the possible
			approaches and provides
			recommendation which to use.
		</para>
	</section>

	<section id="servicecommunication_bundle">
		<title>Using Intent data</title>
		<para>
			In a simple scenario no direct communication is required.
			The
			service
			receives the intent data from the starting Android component
			and performs its work. No notification is necessary. For example, in
			case the service updates a content provider, the activity is notified
			by the content provider and no extra step in the service is
			necessary. This approach works for local and services running in
			their own process.
		</para>
	</section>

	<section id="servicecommunication_receiver">
		<title>Using receiver</title>
		<para>
			You can also use broadcast events and registered receivers for
			the
			communication.
			For example, your
			activity
			can dynamically register a
			broadcast receiver for an event
			and the
			service
			sends outs corresponding
			events. This is a very typical scenario, in which the service need to
			signal to the activity that his processing has finished.
		</para>
		<para>This communication flow is depicted in the following graphic.</para>
		<para>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/service_receiver10.png"/>
				</imageobject>
				<textobject>
					<phrase>Broadcast receiver used for service to activity
						communication</phrase>
				</textobject>
			</mediaobject>
		</para>
		<tip>
			<para>
				Android provides the
				<code>LocalBroadcastManager</code>
				class in the support library v4. This is a helper class to register
				for
				and send broadcasts of Intents to local objects within your
				process. This approach improves security as the broadcast events
				are only visible within your process and is faster than using
				standard events.
			</para>
		</tip>
		<para>
			This approach works for local and services running in their own
			process.
		</para>
	</section>

	<section id="servicecommunication_localbind">
		<title>Activity binding to local service</title>
		<para>
			If the
			service
			is started in the same process as the
			activity, the
			activity
			can directly bind to the service. This is a relatively simple
			and
			efficient way to communicate and recommended for activities
			which need to have a fast communication layer with the service.
		</para>
		<para> This approach works for local services.</para>
	</section>

	<section id="servicecommunication_handler">
		<title>Handler and ResultReceiver or Messenger</title>
		<para>
			If the service should be communicating back to the
			activity,
			it can
			receive an object of type
			<code>Messenger</code>
			via the
			<code>Intent</code>
			data it receives from the
			activity. If the
			<code>Messenger</code>
			is bound to a
			<code>Handler</code>
			in the
			activity,
			the
			<code>service</code>
			can send objects of type
			<code>Message</code>
			to the
			activity.
		</para>
		<para>
			A
			<code>Messenger</code>
			is parcelable, which means it can be passed to another process and
			you
			can use this object to send
			<code>Messages</code>
			to the
			<code>Handler</code>
			in the
			activity.
		</para>
		<para>
			<code>Messenger</code>
			also provides the method
			<code>getBinder()</code>
			which allows passing a
			<code>Messenger</code>
			to the
			activity. The
			activity
			can therefore send
			<code>Messages</code>
			to the
			service.
		</para>
		<para>
			This approach works for local services running in their own
			process.
		</para>
	</section>

	<section id="servicecommunication_ipc">
		<title>AIDL for services in a different process</title>
		<para>
			To bind to a
			service
			which runs in a different process, you need to use
			Inter Process
			Communication (IPC) as the data needs to be sent between
			different
			processes. To do so, you need to create a AIDL file which
			looks
			similar to a Java interface, but ends with the
			<filename>.aidl</filename>
			file extension
			and is only allowed to extend other AIDL files.
		</para>
		<para>
			This approach is required if you need to bind to a service
			running in
			another process, i.e., if your service is consumed by other
			Android applications.
		</para>
		<para>
			You can find more information about this approach in the
			<ulink url="http://developer.android.com/guide/components/aidl.html">
				Android developer documentation about AIDL</ulink>.
		</para>
	</section>
</section>